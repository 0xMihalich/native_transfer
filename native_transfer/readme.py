readme: str = """*NativeTransfer* - класс для работы с Clickhouse Native Format.

Описание формата на официальном сайте(https://clickhouse.com/docs/ru/interfaces/formats#native):

```
Самый эффективный формат. Данные пишутся и читаются блоками в бинарном виде.
Для каждого блока пишется количество строк, количество столбцов, имена и типы столбцов,
а затем кусочки столбцов этого блока, один за другим.
То есть, этот формат является «столбцовым» - не преобразует столбцы в строки.
Именно этот формат используется в родном интерфейсе - при межсерверном взаимодействии,
при использовании клиента командной строки, при работе клиентов, написанных на C++.

Вы можете использовать этот формат для быстрой генерации дампов,
которые могут быть прочитаны только СУБД ClickHouse.
*Вряд ли имеет смысл работать с этим форматом самостоятельно.*
```

Данная библиотека позволяет выполнить обмен данными между Clickhouse Native Format и pandas/polars DataFrame.

Неподдерживаемые типы данных (на данный момент):
Tuple                   # Tuple(T1, T2, ...).
Map                     # Map(K, V).
Variant                 # Variant(T1, T2, ...).
AggregateFunction       # (name, types_of_arguments...) — parametric data type.
SimpleAggregateFunction # (name, types_of_arguments...) data type stores current value (intermediate state) of the aggregate function.
Point                   # stored as a Tuple(Float64, Float64).
Ring                    # stored as an array of points: Array(Point).
LineString              # stored as an array of points: Array(Point).
MultiLineString         # is multiple lines stored as an array of LineString: Array(LineString).
Polygon                 # stored as an array of rings: Array(Ring).
MultiPolygon            # stored as an array of polygons: Array(Polygon).
Expression              # used for representing lambdas in high-order functions.
Set                     # Used for the right half of an IN expression.
Domains                 # You can use domains anywhere corresponding base type can be used.
Nested                  # Nested(name1 Type1, Name2 Type2, ...).
Dynamic                 # This type allows to store values of any type inside it without knowing all of them in advance.
JSON                    # Stores JavaScript Object Notation (JSON) documents in a single column.

Поддерживаемые типы данных:
┌───────────────────────┬────────┬────────┬──────────────────────────────────────┐
│ Тип данных Clickhouse │ Чтение │ Запись │ Тип данных Python (Чтение/запись)    │
╞═══════════════════════╪════════╪════════╪══════════════════════════════════════╡
│ UInt8                 │ +      │ +      │ int/int                              │
│-----------------------+--------+--------+--------------------------------------│
│ UInt16                │ +      │ +      │ int/int                              │
│-----------------------+--------+--------+--------------------------------------│
│ UInt32                │ +      │ +      │ int/int                              │
│-----------------------+--------+--------+--------------------------------------│
│ UInt64                │ +      │ +      │ int/int                              │
│-----------------------+--------+--------+--------------------------------------│
│ UInt128               │ +      │ +      │ int/int                              │
│-----------------------+--------+--------+--------------------------------------│
│ UInt256               │ +      │ +      │ int/int                              │
│-----------------------+--------+--------+--------------------------------------│
│ Int8                  │ +      │ +      │ int/int                              │
│-----------------------+--------+--------+--------------------------------------│
│ Int16                 │ +      │ +      │ int/int                              │
│-----------------------+--------+--------+--------------------------------------│
│ Int32                 │ +      │ +      │ int/int                              │
│-----------------------+--------+--------+--------------------------------------│
│ Int64                 │ +      │ +      │ int/int                              │
│-----------------------+--------+--------+--------------------------------------│
│ Int128                │ +      │ +      │ int/int                              │
│-----------------------+--------+--------+--------------------------------------│
│ Int256                │ +      │ +      │ int/int                              │
│-----------------------+--------+--------+--------------------------------------│
│ Float32               │ +      │ +      │ float/float                          │
│-----------------------+--------+--------+--------------------------------------│
│ Float64               │ +      │ +      │ float/float                          │
│-----------------------+--------+--------+--------------------------------------│
│ BFloat16              │ +      │ +      │ float/float                          │
│-----------------------+--------+--------+--------------------------------------│
│ Decimal(P, S)         │ +      │ -      │ float/-                              │
│-----------------------+--------+--------+--------------------------------------│
│ Decimal32(S)          │ +      │ -      │ float/-                              │
│-----------------------+--------+--------+--------------------------------------│
│ Decimal64(S)          │ +      │ -      │ float/-                              │
│-----------------------+--------+--------+--------------------------------------│
│ Decimal128(S)         │ +      │ -      │ float/-                              │
│-----------------------+--------+--------+--------------------------------------│
│ Decimal256(S)         │ +      │ -      │ float/-                              │
│-----------------------+--------+--------+--------------------------------------│
│ String                │ +      │ +      │ str/str                              │
│-----------------------+--------+--------+--------------------------------------│
│ FixedString(N)        │ +      │ +      │ str/str                              │
│-----------------------+--------+--------+--------------------------------------│
│ Date                  │ +      │ +      │ date/date                            │
│-----------------------+--------+--------+--------------------------------------│
│ Date32                │ +      │ +      │ date/date                            │
│-----------------------+--------+--------+--------------------------------------│
│ DateTime              │ +      │ +      │ datetime/datetime                    │
│-----------------------+--------+--------+--------------------------------------│
│ DateTime64            │ +      │ +      │ datetime/datetime                    │
│-----------------------+--------+--------+--------------------------------------│
│ Enum                  │ +      │ +      │ str/Union[int,Enum]                  │
│-----------------------+--------+--------+--------------------------------------│
│ Bool                  │ +      │ +      │ bool/bool                            │
│-----------------------+--------+--------+--------------------------------------│
│ UUID                  │ +      │ +      │ UUID/UUID                            │
│-----------------------+--------+--------+--------------------------------------│
│ IPv4                  │ +      │ +      │ IPv4Address/IPv4Address              │
│-----------------------+--------+--------+--------------------------------------│
│ IPv6                  │ +      │ +      │ IPv6Address/IPv6Address              │
│-----------------------+--------+--------+--------------------------------------│
│ Array(T)              │ +      │ +      │ List[T*]/List[T*]                    │
│-----------------------+--------+--------+--------------------------------------│
│ LowCardinality(T)     │ +      │ -      │ Union[str,date,datetime,int,float]/- │
│-----------------------+--------+--------+--------------------------------------│
│ Nullable(T)           │ +      │ +      │ Optional[T*]/Optional[T*]            │
│-----------------------+--------+--------+--------------------------------------│
│ Nothing               │ +      │ +      │ None/None                            │
│-----------------------+--------+--------+--------------------------------------│
│ Interval<Type**>      │ +      │ +      │ int/int                              │
└───────────────────────┴────────┴────────┴──────────────────────────────────────┘
*T - любой простой тип данных из перечисленных в таблице
**Type - тип интервала: Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week, Month, Quarter, Year

Особенности реализации некоторых типов данных:

FixedString(N).
Для выбора данного типа из DataFrame нужно быть на 100% уверенным, что длина строки одинаковая.
Возможно, позже добавлю передачу типов данных для записи в класс как параметр.

DateTime64.
Данный тип требует указания precission для точности значений и часовой пояс.
Требуется придумать вариант получения обоих параметров из объекта datetime, либо реализовать явное указание для класса.

Enum.
При использовании данного типа в Clickhouse индексация начинается с 1, в то время как стандартом считается значение 0.
Так же в name могут попадать запрещенные имена, такие как пустая строка и mro. Поэтому, для предотвращения проблемы конвертации,
колонка с Enum явно преобразуется в строки, соответствующие именам Enum. Для обратной записи колонка с Enum значениями напротив
будет явно преобразована в тип данных Int8/Int16.

IPv4/IPv6.
Данные типы данных при чтении в DataFrame могут неявно преобразовываться в строки,
что в свою очередь повлечет за собой смену типа данных колонки во время операции записи.

LowCardinality(T).
Чтение из данного формата выполняется в наследованный формат, упаковка обратно пока не реализована.

Начало работы:

>> # Импортировать логгер.
>> import logging
>> # Импортировать класс из библиотеки.
>> from native_transfer import NativeTransfer
>> # Установить DEBUG level для логгера.
>> logger = logging.getLogger("NativeTransfer")
>> logger.setLevel(logging.DEBUG)
>> # Два необязательных параметра:
>> # block_rows - сколько максимально строк из DataFrame писать в один блок.
>> # logs - передать экземпляр логгера для логирования событий.
>> nt = NativeTransfer(block_rows=65_536, logs=logger)
>> nt
┌────────────────────────────────┐
│ NativeTransfer ver 0.0.1       │
╞════════════════════════════════╡
│ Write Rows Per Block : 65536   │
└────────────────────────────────┘
"""
